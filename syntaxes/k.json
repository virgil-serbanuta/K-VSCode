{
  "name": "k language",
  "scopeName": "text.k",
  "patterns": [
    {"include": "#strings_or_comments"},
    {
      "comment": "require \"file-name\"",

      "begin": "\\b(require)\\b",
      "beginCaptures": {
        "0": {"name": "keyword.require.k"}
      },

      "end": "(?=(\\b(require|module)\\b))",

      "name": "section.require.k",
      "patterns": [
        {"include": "#strings_or_comments"}
      ]
    },
    {
      "comment": "module NAME [attributes] .... endmodule",

      "begin": "^\\s*(module)\\s+([^\\s]+)\\s*((?:\\[[^\\[\\]]*\\])?)$",
      "beginCaptures": {
        "1": {"name": "keyword.module.k"},
        "2": {"name": "entity.name.section.modulename.k"},
        "3": {
          "name": "section.module.attributes.k",
          "patterns": [
            {"include": "#strings_or_comments"},
            {"include": "#attributes"}
          ]
        }
      },

      "end": "\\bendmodule\\b",
      "endCaptures": {
        "0": {
          "name": "keyword.module.k"
        }
      },

      "name": "section.module.k",

      "patterns": [
        {"include": "#strings_or_comments"},
        {
          "comment": "import MODULE-NAME",

          "begin": "\\b(imports)\\s+([^\\s]+)\\s*$",
          "beginCaptures": {
            "1": {"name": "keyword.imports.k"},
            "2": {
              "name": "entity.name.section.modulename.k",
              "patterns": [
                {"include": "#strings_or_comments"}
              ]
            }
          },

          "end": "(?=(\\b(imports|syntax|context|configuration|rule|endmodule)\\b))",

          "name":"section.imports.k",

          "patterns": [
            {"include": "#strings_or_comments"}
          ]
        },
        {
          "comment": "rule [context]: left => right [attributes]",

          "begin": "\\b(rule)\\s*(\\[)([^\\[\\]]*)(\\]):",
          "beginCaptures": {
            "1": {"name": "keyword.rule.k"},
            "2": {"name": "punctuation.rule.context.k"},
            "3": {"name": "entity.name.context.k"},
            "4": {"name": "punctuation.rule.context.k"}
          },

          "end": "(?=(\\b(imports|syntax|context|configuration|rule|endmodule)\\b))",

          "name":"section.rule.k",

          "patterns": [
            {"include": "#rule_patterns"}
          ]
        },
        {
          "comment": "rule left => right [attributes]",
          "begin": "\\brule\\b",

          "beginCaptures": {
            "0": {"name": "keyword.rule.k"}
          },

          "end": "(?=(\\b(imports|syntax|context|configuration|rule|endmodule)\\b))",

          "name":"section.rule.k",

          "patterns": [
            {"include": "#rule_patterns"}
          ]
        },
        {
          "comment": "syntax Sort ::= thing | thing [attributes]",

          "begin": "\\b(syntax)\\b",
          "beginCaptures": {
            "0": {"name": "keyword.syntax.k"}
          },

          "end": "(?=(\\b(imports|syntax|context|configuration|rule|endmodule)\\b))",

          "name":"section.syntax.k",

          "patterns": [
            {"include": "#strings_or_comments"},
            {"include": "#attributes"},
            {
              "match": "::=|>|\\|",
              "name": "keyword.syntax.punctuation.k"
            },
            {"include": "#punctuation"}
          ]
        },
        {
          "comment": "syntax associativity left a b",

          "begin": "\\b(syntax\\s+(associativity\\s+)?(left|right))\\b",
          "beginCaptures": {
            "0": {"name": "keyword.syntax.k"}
          },

          "end": "(?=(\\b(imports|syntax|context|configuration|rule|endmodule)\\b))",

          "name":"section.syntax.k",

          "patterns": [
            {"include": "#strings_or_comments"},
            {"include": "#attributes"},
            {"include": "#punctuation"}
          ]
        },
        {
          "comment": "syntax priority a > b c > d",

          "begin": "\\b(syntax\\s+(priority|priorities))\\b",
          "beginCaptures": {
            "0": {"name": "keyword.syntax.k"}
          },

          "end": "(?=(\\b(imports|syntax|context|configuration|rule|endmodule)\\b))",

          "name":"section.syntax.k",

          "patterns": [
            {"include": "#strings_or_comments"},
            {"include": "#attributes"},
            {
              "match": ">",
              "name": "keyword.syntax.punctuation.k"
            },
            {"include": "#punctuation"}
          ]
        },
        {
          "comment": "context alias [rval]: elaborate(HERE) [result(Resolved), context(elaborate)]",

          "begin": "\\b(context)\\s+(alias)\\s*(\\[[^\\]]*\\]:)",
          "beginCaptures": {
            "1": {"name": "keyword.context.k"},
            "2": {"name": "keyword.context.k"},
            "3": {"name": "entity.name.context-alias.k"}
          },

          "end": "(?=(\\b(imports|syntax|context|configuration|rule|endmodule)\\b))",

          "name":"section.context.k",

          "patterns": [
            {"include": "#context_alias_configuration_patterns"},
            {"include": "#hole_here"}
          ]
        },
        {
          "comment": "context term(HOLE)",

          "begin": "\\b(context)\\b",
          "beginCaptures": {
            "0": {"name": "keyword.context.k"}
          },

          "end": "(?=(\\b(imports|syntax|context|configuration|rule|endmodule)\\b))",

          "name":"section.context.k",

          "patterns": [
            {"include": "#rule_patterns"},
            {"include": "#hole_here"}
          ]
        },
        {
          "comment": "configuration <thing></thing>",

          "begin": "\\b(configuration)\\b",
          "beginCaptures": {
            "0": {"name": "keyword.configuration.k"}
          },

          "end": "(?=(\\b(imports|syntax|context|configuration|rule|endmodule)\\b))",

          "name":"section.configuration.k",

          "patterns": [
            {"include": "#context_alias_configuration_patterns"}
          ]
        }
      ]
    }
  ],
  "repository": {
    "block_comment": {
      "comment": "/* this is a comment */",

      "begin": "/\\*",
      "end": "\\*/",

      "name": "comment.block.k"
    },
    "line_comment": {
      "comment": "// this is a comment",

      "match": "//.*$",
      "name": "comment.line.k"
    },
    "comments": {
      "comment": "/* comment */ and // comment",

      "patterns": [
        {"include": "#line_comment"},
        {"include": "#block_comment"}
      ]
    },
    "strings": {
      "match": "\"([^\"\\\\]*(\\\\.)?)*\"",
      "name": "string.value.quoted.double.k"
    },
    "strings_regexp": {
      "match": "r\"([^\"\\\\]*(\\\\.)?)*\"",
      "name": "string.regexp.quoted.double.k"
    },
    "strings_or_comments": {
      "patterns": [
        {"include": "#comments"},
        {"include": "#strings"},
        {"include": "#strings_regexp"}
      ]
    },
    "attribute_name": {
      "match": "\\b(strict|avoid|prefer|bracket|non-assoc|seqstrict|left|right|macro|token|notInRules|autoReject|structural|latex|binder|klabel|symbol|amb|hook|unit|function|functional|result|assoc|comm|idem|element|format|smtlib|anywhere|context|smt-hook|owise|label)\\b",
      "name": "entity.name.attribute.k"
    },
    "attributes": {
      "comment": "[label(\"name\"), hook]",

      "begin": "(\\[)(?=[^\\[])",
      "beginCaptures":  {
        "1": {"name": "punctuation.attribute.k"}
      },
      "end": "\\]",
      "endCaptures":  {
        "1": {"name": "punctuation.attribute.k"}
      },

      "name": "section.attribute.k",
      "patterns": [
        {"include": "#strings_or_comments"},
        {"include": "#attribute_name"}
      ]
    },
    "context_alias_configuration_patterns": {
      "patterns": [
        {"include": "#strings_or_comments"},
        {"include": "#attributes"},
        {"include": "#constant"},
        {"include": "#rule_keywords"},
        {"include": "#operators"},
        {"include": "#predefined"},
        {"include": "#punctuation"},
        {"include": "#configuration_tags"},
        {"include": "#user_operators_low_priority"}
      ]
    },
    "rule_patterns": {
      "patterns": [
        {"include": "#strings_or_comments"},
        {
          "comment": "[[ left => right ]] <cell> ... </cell>",

          "begin": "\\[\\[",
          "beginCaptures":  {
            "0": {"name": "punctuation.function-with-configuration.k"}
          },
          "end": "\\]\\]",
          "beginCaptures":  {
            "0": {"name": "punctuation.function-with-configuration.k"}
          },

          "name": "section.function-with-configuration.k",
          "patterns": [
            {"include": "#rule_patterns"}
          ]
        },
        {"include": "#attributes"},
        {"include": "#constant"},
        {"include": "#rule_keywords"},
        {"include": "#operators"},
        {"include": "#predefined"},
        {"include": "#punctuation"},
        {
          "match": "=>",
          "name": "keyword.syntax.k"
        },
        {
          "match": "\\b(requires|ensures|when)\\b",
          "name": "keyword.syntax.k"
        },
        {"include": "#configuration_tags"},
        {"include": "#user_operators_low_priority"}
      ]
    },
    "configuration_open_tag": {
      "comment": "<tag attr=\"value\">",
      "begin": "(<)\\s*(\\w[\\w\\d\\-\\_]*)",
      "beginCaptures": {
        "1": {"name": "punctuation.definition.tag.k"},
        "2": {"name": "entity.name.tag.k"}
      },

      "end": "\\s*(>)",
      "endCaptures": {
        "1": {"name": "punctuation.definition.tag.k"}
      },

      "patterns": [
        {
          "comment": "attr=\"value\"",

          "match": "([\\w\\d\\-\\_]+)\\s*\\=\\s*(\".+?\")",
          "captures": {
            "1": {"name": "constant.regexp.emphasis.strong.tags.k"},
            "2": {"name": "string.quoted.double.k"}
          }
        }
      ]
    },
    "configuration_closed_tag": {
      "comment": "</tag>",

      "match": "(<)\\s*/([\\w\\d\\-\\_]+?)\\s*(>)",
      "captures": {
        "1": {"name": "punctuation.definition.tag.k"},
        "2": {"name": "entity.name.tag.k"},
        "3": {"name": "punctuation.definition.tag.k"}
      }
    },
    "configuration_tags": {
      "patterns": [
        {"include": "#configuration_open_tag"},
        {"include": "#configuration_closed_tag"}
      ]
    },
    "generic_operators": {
      "match": "\\?",
      "name": "keyword.operator.k"
    },
    "equality_operators": {
      "comment": "==Int",
      "match": "(==|=/=)(Int|Float|String|MInt|Bool|K)\\b",
      "name": "keyword.operator.k"
    },
    "comparison_operators": {
      "comment": "<Int",
      "match": "(<|<=|>|>=)(Int|Float|String|sMInt|uMInt)\\b",
      "name": "keyword.operator.k"
    },
    "number_operators": {
      "comment": "+Int",
      "match": "(\\+|-|\\*)(Int|Float|MInt)\\b",
      "name": "keyword.operator.k"
    },
    "floatint_operators": {
      "comment": "^Int",
      "match": "(\\^)(Int|Float)\\b",
      "name": "keyword.operator.k"
    },
    "floatmint_operators": {
      "match": "(--)(MInt|Float)\\b",
      "name": "keyword.operator.k"
    },
    "signed_operators": {
      "match": "(/|%)(Int|Float|uMInt|sMInt)\\b",
      "name": "keyword.operator.k"
    },
    "bit_operators": {
      "match": "(~|<<|&|\\||\\bxor)(Int|MInt)\\b",
      "name": "keyword.operator.k"
    },
    "punctuation_operators": {
      "match": "(\\^\\%Int|>>Int|\\+String|>>aMInt|>>lMInt)\\b",
      "name": "keyword.operator.k"
    },
    "user_operators": {
      "match": "==|=/=|!=|<=|>=|\\+|\\+\\+|-|--|\\*|\\^|/|%|~|<<|>>|&|\\||!|=",
      "name": "keyword.operator.k"
    },
    "user_operators_low_priority": {
      "match": "<|>",
      "name": "keyword.operator.k"
    },
    "int_letter_operators": {
      "match": "\\b(div|mod|divides)Int\\b",
      "name": "keyword.operator.k"
    },
    "bool_letter_operators": {
      "match": "\\b(not|and|andThen|xor|or|orElse|implies)Bool\\b",
      "name": "keyword.operator.k"
    },
    "list_map_operators": {
      "match": "~>|\\|->|<-",
      "name": "keyword.operator.k"
    },
    "operators": {
      "patterns": [
        {"include": "#generic_operators"},
        {"include": "#equality_operators"},
        {"include": "#comparison_operators"},
        {"include": "#number_operators"},
        {"include": "#floatint_operators"},
        {"include": "#floatmint_operators"},
        {"include": "#signed_operators"},
        {"include": "#list_map_operators"},
        {"include": "#bit_operators"},
        {"include": "#punctuation_operators"},
        {"include": "#int_letter_operators"},
        {"include": "#bool_letter_operators"},
        {"include": "#user_operators"}
      ]
    },
    "numeric_constant": {
      "match": "(-|\\.)?\\b[0-9]+(\\.[0-9]+)?\\b",
      "name": "constant.numeric.k"
    },
    "bool_constant": {
      "match": "\\b(true|false)\\b",
      "name": "constant.numeric.k"
    },
    "constant": {
      "patterns": [
        {"include": "#numeric_constant"},
        {"include": "#bool_constant"}
      ]
    },
    "keyword_punctuation": {
      "match": "(=>|\\.\\.\\.|::=|::|:>)",
      "name": "keyword.reserved.k"
    },
    "ml_keywords": {
      "match": "(#True|#False|#And|#Or|#Not|#Implies|#Iff|#Equals|#Ceil|#Floor|#Exists|#Forall|#Rewrites|#AG|#wEF\\b)",
      "name": "keyword.control.flow"
    },
    "other_keywords": {
      "match": "(#as|\\.Bag|#fun\\b)",
      "name": "keyword.control.flow"
    },
    "rule_keywords": {
      "patterns": [
        {"include": "#keyword_punctuation"},
        {"include": "#ml_keywords"},
        {"include": "#other_keywords"}
      ]
    },
    "punctuation": {
      "match": "\\(|\\)|\\[|\\]|\\{|\\}|,",
      "name": "punctuation.separator.k"
    },
    "predefined_constants": {
      "match": "(\\.List|\\.Map|\\.Set|\\.Bag|\\.K|\\.KList|\\bundef)\\b",
      "name": "constant.numeric.k"
    },
    "predefined_sorts": {
      "match": "\\b(Id|Int|Bool|String|MInt|Token|Lexer|Float|Kresult|List|Map|Set|Bag|KItem|K|KList)\\b",
      "name": "support.type.k"
    },
    "predefined_symbols": {
      "match": "\\b(ListItem|SetItem|BagItem)\\b",
      "name": "support.symbol.k"
    },
    "predefined": {
      "patterns": [
        {"include": "#predefined_constants"},
        {"include": "#predefined_sorts"},
        {"include": "#predefined_symbols"}
      ]
    },
    "hole_here": {
      "match": "HOLE|HERE",
      "name": "support.variable.k"
    }
  }

}
